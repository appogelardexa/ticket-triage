-- =========================================================
-- Ticket Triage - Full Database Schema (PostgreSQL/Supabase)
-- Enums, tables, FKs, indexes, generated columns, history,
-- trigger functions, and triggers for status & priority.
-- =========================================================

-- --------------------
-- ENUM TYPES
-- --------------------
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'staff_status') THEN
    CREATE TYPE staff_status AS ENUM ('active','inactive','on_leave');
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ticket_status') THEN
    CREATE TYPE ticket_status AS ENUM ('new','open','in_progress','on_hold','resolved','closed','reopened');
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ticket_priority') THEN
    CREATE TYPE ticket_priority AS ENUM ('P1','P2','P3','low','normal','high','urgent');
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ticket_channel') THEN
    CREATE TYPE ticket_channel AS ENUM ('email','web','chat','phone','manual','api');
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ticket_event_type') THEN
    CREATE TYPE ticket_event_type AS ENUM ('created','status_changed','priority_changed','assigned','commented','external_linked');
  END IF;
END $$;

-- --------------------
-- TABLES
-- --------------------

-- Companies
CREATE TABLE IF NOT EXISTS public.companies (
  id              bigserial PRIMARY KEY,
  name            text NOT NULL UNIQUE,
  description     text,
  status          text,
  created_at      timestamptz DEFAULT now()
);

-- Clients
CREATE TABLE IF NOT EXISTS public.clients (
  id              bigserial PRIMARY KEY,
  name            text NOT NULL,
  email           text UNIQUE,
  company_id      bigint REFERENCES public.companies(id) ON DELETE SET NULL,
  domain          text,
  created_at      timestamptz DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_clients_company_id ON public.clients(company_id);

-- Departments
CREATE TABLE IF NOT EXISTS public.departments (
  id              bigserial PRIMARY KEY,
  name            text NOT NULL UNIQUE,
  google_channel  text,
  created_at      timestamptz DEFAULT now()
);

-- Internal Staff
CREATE TABLE IF NOT EXISTS public.internal_staff (
  id              bigserial PRIMARY KEY,
  name            text NOT NULL,
  email           text NOT NULL UNIQUE,
  department_id   bigint REFERENCES public.departments(id) ON DELETE SET NULL,
  status          staff_status NOT NULL DEFAULT 'active',
  created_at      timestamptz DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_internal_staff_department_id ON public.internal_staff(department_id);

-- Departments.default_assignee_id
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name='departments' AND column_name='default_assignee_id'
  ) THEN
    ALTER TABLE public.departments
      ADD COLUMN default_assignee_id bigint REFERENCES public.internal_staff(id) ON DELETE SET NULL;
  END IF;
END $$;

-- Categories
CREATE TABLE IF NOT EXISTS public.categories (
  id                      bigserial PRIMARY KEY,
  name                    text NOT NULL,
  department_id           bigint NOT NULL REFERENCES public.departments(id) ON DELETE CASCADE,
  default_slack_channel   text,
  auto_assign_to_id       bigint REFERENCES public.internal_staff(id) ON DELETE SET NULL,
  created_at              timestamptz DEFAULT now(),
  UNIQUE (department_id, name)
);
CREATE INDEX IF NOT EXISTS idx_categories_department_id ON public.categories(department_id);
CREATE INDEX IF NOT EXISTS idx_categories_auto_assign_to_id ON public.categories(auto_assign_to_id);

-- Tickets
CREATE TABLE IF NOT EXISTS public.tickets (
  id                      bigint GENERATED BY DEFAULT AS IDENTITY (START WITH 1000) PRIMARY KEY,
  ticket_id               text GENERATED ALWAYS AS ('TCK-' || lpad(id::text, 6, '0')) STORED,
  UNIQUE (ticket_id),

  status                  ticket_status   NOT NULL DEFAULT 'new',
  priority                ticket_priority NOT NULL DEFAULT 'normal',
  channel                 ticket_channel  NOT NULL DEFAULT 'email',

  summary                 text NOT NULL,
  body                    text,
  subject                 text, 
  message_id              text,
  thread_id               text,

  client_id               bigint REFERENCES public.clients(id) ON DELETE SET NULL,
  assignee_id             bigint REFERENCES public.internal_staff(id) ON DELETE SET NULL,
  department_id           bigint REFERENCES public.departments(id) ON DELETE SET NULL,
  category_id             bigint REFERENCES public.categories(id) ON DELETE SET NULL,

  created_at              timestamptz NOT NULL DEFAULT now(),
  updated_at              timestamptz NOT NULL DEFAULT now(),
  -- status_last_modified    timestamptz,
  -- priority_last_modified  timestamptz,
  -- assignee_last_modified  timestamptz
);

CREATE INDEX IF NOT EXISTS idx_tickets_client_id     ON public.tickets(client_id);
CREATE INDEX IF NOT EXISTS idx_tickets_assignee_id   ON public.tickets(assignee_id);
CREATE INDEX IF NOT EXISTS idx_tickets_department_id ON public.tickets(department_id);
CREATE INDEX IF NOT EXISTS idx_tickets_category_id   ON public.tickets(category_id);
CREATE INDEX IF NOT EXISTS idx_tickets_status        ON public.tickets(status);
CREATE INDEX IF NOT EXISTS idx_tickets_priority      ON public.tickets(priority);

-- Event Logs
CREATE TABLE IF NOT EXISTS public.event_logs (
  id            bigserial PRIMARY KEY,
  ticket_id     bigint NOT NULL REFERENCES public.tickets(id) ON DELETE CASCADE,
  type          ticket_event_type NOT NULL,
  occurred_at   timestamptz NOT NULL DEFAULT now(),
  link          text
);
CREATE INDEX IF NOT EXISTS idx_event_logs_ticket_time ON public.event_logs(ticket_id, occurred_at DESC);

-- --------------------
-- HISTORY TABLES
-- --------------------

CREATE TABLE IF NOT EXISTS public.ticket_status_history (
  id           bigserial PRIMARY KEY,
  ticket_id    bigint NOT NULL REFERENCES public.tickets(id) ON DELETE CASCADE,
  from_status  ticket_status,
  to_status    ticket_status NOT NULL,
  changed_at   timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_tsh_ticket_time ON public.ticket_status_history(ticket_id, changed_at);

CREATE TABLE IF NOT EXISTS public.ticket_priority_history (
  id            bigserial PRIMARY KEY,
  ticket_id     bigint NOT NULL REFERENCES public.tickets(id) ON DELETE CASCADE,
  from_priority ticket_priority,
  to_priority   ticket_priority NOT NULL,
  changed_at    timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_tph_ticket_time ON public.ticket_priority_history(ticket_id, changed_at);

-- --------------------
-- TRIGGER FUNCTIONS
-- --------------------
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.set_ticket_change_timestamps()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.status IS DISTINCT FROM OLD.status THEN
    NEW.status_last_modified := now();
  END IF;
  IF NEW.priority IS DISTINCT FROM OLD.priority THEN
    NEW.priority_last_modified := now();
  END IF;
  IF NEW.assignee_id IS DISTINCT FROM OLD.assignee_id THEN
    NEW.assignee_last_modified := now();
  END IF;
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.log_status_on_insert()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO public.ticket_status_history (ticket_id, from_status, to_status, changed_at)
  VALUES (NEW.id, NULL, NEW.status, now());
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.log_status_on_update()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.status IS DISTINCT FROM OLD.status THEN
    INSERT INTO public.ticket_status_history (ticket_id, from_status, to_status, changed_at)
    VALUES (NEW.id, OLD.status, NEW.status, now());
  END IF;
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.log_priority_on_insert()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  INSERT INTO public.ticket_priority_history (ticket_id, from_priority, to_priority, changed_at)
  VALUES (NEW.id, NULL, NEW.priority, now());
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.log_priority_on_update()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.priority IS DISTINCT FROM OLD.priority THEN
    INSERT INTO public.ticket_priority_history (ticket_id, from_priority, to_priority, changed_at)
    VALUES (NEW.id, OLD.priority, NEW.priority, now());
  END IF;
  RETURN NEW;
END;
$$;

-- --------------------
-- TRIGGERS
-- --------------------
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_tickets_updated_at') THEN
    CREATE TRIGGER trg_tickets_updated_at
    BEFORE UPDATE ON public.tickets
    FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_tickets_change_flags') THEN
    CREATE TRIGGER trg_tickets_change_flags
    BEFORE UPDATE ON public.tickets
    FOR EACH ROW EXECUTE FUNCTION public.set_ticket_change_timestamps();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_tickets_status_insert') THEN
    CREATE TRIGGER trg_tickets_status_insert
    AFTER INSERT ON public.tickets
    FOR EACH ROW EXECUTE FUNCTION public.log_status_on_insert();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_tickets_status_update') THEN
    CREATE TRIGGER trg_tickets_status_update
    AFTER UPDATE OF status ON public.tickets
    FOR EACH ROW EXECUTE FUNCTION public.log_status_on_update();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_tickets_priority_insert') THEN
    CREATE TRIGGER trg_tickets_priority_insert
    AFTER INSERT ON public.tickets
    FOR EACH ROW EXECUTE FUNCTION public.log_priority_on_insert();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trg_tickets_priority_update') THEN
    CREATE TRIGGER trg_tickets_priority_update
    AFTER UPDATE OF priority ON public.tickets
    FOR EACH ROW EXECUTE FUNCTION public.log_priority_on_update();
  END IF;
END $$;

-- --------------------
-- OPTIONAL VIEWS
-- --------------------
CREATE OR REPLACE VIEW public.tickets_with_client AS
SELECT
  t.id,
  t.ticket_id,
  t.status,
  t.priority,
  t.channel,
  t.summary,
  t.client_id,
  c.name  AS client_name,
  c.email AS client_email,
  c.domain AS client_domain,
  co.name AS company_name,          -- <- from companies via company_id
  t.created_at,
  t.updated_at
FROM public.tickets t
LEFT JOIN public.clients   c  ON c.id = t.client_id
LEFT JOIN public.companies co ON co.id = c.company_id;



CREATE OR REPLACE VIEW public.tickets_status_timeline AS
SELECT
  t.id,
  t.ticket_id,
  MIN(h.changed_at) FILTER (WHERE h.to_status='new')         AS new_at,
  MIN(h.changed_at) FILTER (WHERE h.to_status='open')        AS open_at,
  MIN(h.changed_at) FILTER (WHERE h.to_status='in_progress') AS in_progress_at,
  MIN(h.changed_at) FILTER (WHERE h.to_status='on_hold')     AS on_hold_at,
  MIN(h.changed_at) FILTER (WHERE h.to_status='resolved')    AS resolved_at,
  MIN(h.changed_at) FILTER (WHERE h.to_status='closed')      AS closed_at
FROM public.tickets t
LEFT JOIN public.ticket_status_history h ON h.ticket_id = t.id
GROUP BY t.id, t.ticket_id;

CREATE OR REPLACE VIEW public.tickets_priority_timeline AS
SELECT
  t.id,
  t.ticket_id,
  MIN(h.changed_at) FILTER (WHERE h.to_priority='P1')     AS first_p1_at,
  MIN(h.changed_at) FILTER (WHERE h.to_priority='P2')     AS first_p2_at,
  MIN(h.changed_at) FILTER (WHERE h.to_priority='P3')     AS first_p3_at,
  MIN(h.changed_at) FILTER (WHERE h.to_priority='low')    AS first_low_at,
  MIN(h.changed_at) FILTER (WHERE h.to_priority='normal') AS first_normal_at,
  MIN(h.changed_at) FILTER (WHERE h.to_priority='high')   AS first_high_at,
  MIN(h.changed_at) FILTER (WHERE h.to_priority='urgent') AS first_urgent_at
FROM public.tickets t
LEFT JOIN public.ticket_priority_history h ON h.ticket_id = t.id
GROUP BY t.id, t.ticket_id;

-- -------------------------------------------------
-- Ticket Attachments
-- -------------------------------------------------
-- Stores metadata for files kept in Supabase Storage.
-- We keep only the object path (relative to bucket).
-- The physical file is managed in storage; rows cascade on ticket delete.
CREATE TABLE IF NOT EXISTS public.ticket_attachments (
  id           bigserial PRIMARY KEY,
  ticket_id    bigint REFERENCES public.tickets(id) ON DELETE CASCADE,
  file_path    text NOT NULL,              -- e.g., "tickets/TCK-000123/uuid-filename.ext"
  filename     text,                       -- original or display name
  mime_type    text,
  size_bytes   bigint,
  created_at   timestamptz DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_ticket_attachments_ticket_id ON public.ticket_attachments(ticket_id);
